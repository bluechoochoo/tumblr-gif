#!/bin/bash
# ---------------------------------------------
# Artifact:     tumblr-gif/tumblr-gif
# Version:      0.1.0
# Date (UTC):   Mon, 17 Feb 2014 15:54:25 +0000
# Generated by: bashing 0.2.0
# ---------------------------------------------
export __BASHING_VERSION='0.2.0'
export __VERSION='0.1.0'
export __ARTIFACT_ID='tumblr-gif'
export __GROUP_ID='tumblr-gif'
set -eu
if [[ -z "${WORKSPACE-}" ]]; then
    WORKSPACE=/tmp/tumblr-gif
fi
if [[ -z "${RC_FILE-}" ]]; then
    RC_FILE="$HOME/.tumblr-gif-rc.sh"
fi
function is_debug_enable() {
    [[ -n "${DEBUG-}" ]]
}
function debug() {
    if is_debug_enable
    then echo "$@"
    fi
}
function set_x() {
    if is_debug_enable
    then set -x
    fi
}
function abort() {
    err "$@"
    exit $(status_code "$*")
}
function status_code() {
    local c=$(hash_code 255 "$*")
    echo $((c + 1))
}
function hash_code() {
    local base=$1
    shift
    local s=$(sum <<< "$*" | cut -d' ' -f1)
    bc <<< "$s % $base"
}
function err() {
    echo "$@" >&2
}
function is_int() {
    [[ "$1" =~ [0-9]+ ]]
}
function clean_files() {
    rm -vrf -- "$WORKSPACE"/*
}
MAX_FILE_SIZE=$((990 * 1000)) # 990 KB
MIN_FILE_SIZE=$((985 * 1000)) # 990 KB
MAX_SIDE=500
MIN_SIDE=230
function do_convert() {
    gen_gif $init_width
    local sides="$(get_geometry)"
    local base_width=$(cut -dx -f1 <<< "$sides")
    local base_height=$(cut -dx -f2 <<< "$sides")
    if [[ $base_width -eq $MAX_SIDE || $base_height -eq $MAX_SIDE ]] \
        && [[ $(stat -c%s "$output_gif") -lt $MAX_FILE_SIZE ]]; then
        echo "Success!"
        return 0
    fi
    if is_valid_sides $base_width $base_height && is_valid_size; then
        echo "Success!"
        return 0
    fi
    local w h
    while true ; do
        w=$(next_width)
        h=$(((base_height * w) / base_width))
        if ! is_valid_sides $w $h; then
            abort "Failure: delete some images on $WORKSPACE"
        fi
        gen_gif $w
        if is_valid_size; then
            break
        fi
    done
    echo "Success"
}
function is_valid_size() {
    [[ $(stat -c%s "$output_gif") -lt $MAX_FILE_SIZE \
        && $(stat -c%s "$output_gif") -gt $MIN_FILE_SIZE ]] || return 1
}
function is_valid_sides() {
    local width=$1
    local height=$2
    if [[ $width -gt $height ]]; then # the long side is width
        [[ $width -le $MAX_SIDE ]] || (echo "Too long width"; return 1)
        [[ $width -ge $MIN_SIDE ]] || (echo "Too short width"; return 1)
    else # the long side is height
        [[ $height -le $MAX_SIDE ]] || (echo "Too long height"; return 1)
        [[ $height -ge $MIN_SIDE ]] || (echo "Too short height"; return 1)
    fi
}
function get_geometry() {
    identify -format '%[fx:w]x%[fx:h]\n' "$output_gif" | head -n 1
    return ${PIPESTATUS[0]}
}
function get_width() {
    identify -format '%[fx:w]\n' "$output_gif" | head -n 1
    return ${PIPESTATUS[0]}
}
function get_size() {
    stat -c%s "$output_gif"
}
function next_width() {
    local w=$(get_width "$output_gif")
    local s=$(get_size "$output_gif")
    evenize $(bc -l <<< "sqrt($MAX_FILE_SIZE / $s) * $w")
}
function evenize() {
    local i=${1%.*}
    echo $((i / 2 * 2))
}
gen_counter=1
function gen_gif() {
    local width="$1"
    local delay=$((delay_factor * frame_interval))
    local arg="-delay $delay"
    local last_i=$(ls $WORKSPACE | wc -l)
    last_i=$(((last_i / frame_interval)  * frame_interval))
    last_i=$((last_i - frame_interval))
    set +x
    local f i=0
    for f in $(ls $WORKSPACE | sort -n); do
        if [[ $((i % frame_interval)) -eq 0 ]]; then
            f="$WORKSPACE/$f"
            if [[ $i -eq $last_i ]]
            then arg="$arg -delay $last_delay '$f'"
            else arg="$arg '$f'"
            fi
        fi
        i=$((i + 1))
    done
    set_x
    echo_and_eval convert $arg -loop 0 \
        -geometry "${width}x" \
        -fuzz ${fuzz}% \
        -dither FloydSteinberg \
        -modulate "100,$saturation" \
        -layers optimize "$output_gif"
    local s="$(ls -sh "$output_gif"|tail -n 1|awk '{print $1}')"
    echo -e "#${gen_counter}\t$(get_geometry) \t${s}B";
    gen_counter=$((gen_counter + 1))
}
function echo_and_eval() {
    if $is_echo_convert
    then echo "$@"
    fi
    eval "$@"
}
function hook_after_view() {
    [[ $# -gt 0 ]] || return
    if type after_view &> /dev/null
    then after_view "$@"
    else echo "Generate png files: $@"
    fi
}
function hook_after_gen() {
    [[ $# -eq 1 ]] || return
    if type after_gen &> /dev/null
    then after_gen "$1"
    else echo "Build gif: $1"
    fi
}
function load_rc() {
    if [[ ! -f "$RC_FILE" ]]
    then create_rc
    fi
    debug "load $RC_FILE"
    . "$RC_FILE"
}
function create_rc() {
    echo "Create default config: $RC_FILE"
    if ! [[ "$0" =~ tumblr-gif ]]; then
        echo '#!/bin/bash -eu' > "$RC_FILE"
        return 0
    fi
    start=$(grep -Pn '##[S]TART_SAMPLE_CONF' $0 | cut -d: -f1)
    end=$(grep -Pn '##[E]ND_SAMPLE_CONF' $0 | cut -d: -f1)
    head -n $((end - 1)) $0 \
        | tail -n $((end - start - 1)) \
        | sed -e 's/^ *://' > "$RC_FILE"
    return 0
: '
:##START_SAMPLE_CONF
:#!/bin/bash -eu
:# -*- coding:utf-8; mode:sh; -*-
:
:###########################################################
:## env
:
:# export PATH="${HOME}/local/bin:${PATH}"
:# export LD_LIBRARY_PATH="${HOME}/local/lib:${LD_LIBRARY_PATH-}"
:
:###########################################################
:## hooks on each tasks
:
:after_view() { # argument: generated png file pathes
:    echo "generate $# PNG files"
:    xdg-open "$(dirname "$1")"
:}
:
:after_gen() { # artument: a generated gif path
:    xdg-open "$1"
:}
:##END_SAMPLE_CONF
'
}
function cli_clean() {
  clean_files
  return 0;
}
function cli_gen() {
  usage="Usage: $(basename "$0") [<option> [ ... ] ] <output_gif>
      -s,--saturation NUM     :
          set this smaller NUM if tumblr return \"Error uploading image\".
          default: 95, max: 100, min: 1.
      -w,--init-width NUM     : default: 500
      -f,--fuzz NUM           :
          set this smaller NUM then a smaller gif was generated. default: 2.
      -i,--frame-interval NUM :
          set this larger NUM then a smaller gif was generated. default: 1.
      -l,--last-delay NUM     :
          set this larger NUM if you want a gif which has the last frame stop
          for NUM delay.
          default: ( delay-factor * frame-interval )
      --delay-factor NUM      :
          set this larger NUM if you want a gif at faster speed animation.
          default: 3
      --echo-convert          : output 'convert' cmmands
      -h,--help
  "
  saturation=95
  init_width=500
  fuzz=2
  frame_interval=2
  last_delay=
  delay_factor=3
  output_gif=
  is_echo_convert=false
  while [[ $# -gt 0 ]]; do
      case "$1" in
          -s|--saturation)
              is_int "$2" || abort "$1 argument must integer: $2"
              saturation="$2"
              shift
              ;;
          -w|--init-width)
              is_int "$2" || abort "$1 argument must integer: $2"
              init_width="$2"
              shift
              ;;
          -f|--fuzz)
              is_int "$2" || abort "$1 argument must integer: $2"
              fuzz="$2"
              shift
              ;;
          -i|--frame-interval)
              is_int "$2" || abort "$1 argument must integer: $2"
              frame_interval="$2"
              shift
              ;;
          -l|--last-delay)
              is_int "$2" || abort "$1 argument must integer: $2"
              last_delay=$2
              shift
              ;;
          --delay-factor)
              is_int "$2" || abort "$1 argument must integer: $2"
              delay_factor=$2
              shift
              ;;
          --echo-convert)
              is_echo_convert="true"
              ;;
          -h|--help) abort "$usage" ;;
          -*) abort "unknown option: $1" ;;
          *)
              [[ -z "$output_gif" ]] || abort "invalid argument: $1"
              output_gif="$1"
              ;;
      esac
      shift
  done
  if [[ -z "$last_delay" ]]
  then last_delay=$((delay_factor * frame_interval))
  fi
  if [[ -z "$output_gif" ]]
  then abort "$usage"
  fi
  (
      for v in saturation init_width fuzz frame_interval last_delay delay_factor \
          is_echo_convert output_gif
      do eval echo "$v : \$$v"
      done
      echo ---------------
  ) | column -t
  do_convert
  hook_after_gen "$output_gif"
  return 0;
}
function cli_view() {
  usage="Usage: $(basename "$0") view <video_file> <offset_time> <duration_sec>
    <offset_time>: HH:MM:SS or HH:MM:SS.ss"
  if [[ $# -ne 3 ]]; then
      abort "$usage"
  fi
  clean_files
  video_file="$1"
  offset_time="$2"
  duration_sec="$3"
  mkdir -pv "$WORKSPACE"
  avconv -deinterlace -i "$video_file" -f image2 \
      -ss "$offset_time" -r 3 -s '500x280' \
      -t "$duration_sec" "$WORKSPACE/%04d.png"
  pngs=()
  set +u
  for p in $WORKSPACE/*.png; do
      if [[ -f "$p" ]]
      then pngs=("${pngs[@]}" "$p")
      fi
  done
  if [[ ${#pngs} -gt 0 ]]
  then hook_after_view "${pngs[@]}"
  else abort "ERROR: no png on '$WORKSPACE'"
  fi
  set -u
  return 0;
}
function __run() {
  local pid=""
  local status=255
  set_x
  load_rc
  avconv -version &>/dev/null || avconv
  convert -version &>/dev/null || convert
  local cmd="${1-}"
  shift || true
  case "$cmd" in
    "") __run "help"; return $?;;
    "clean") cli_clean "$@" & local pid="$!";;
    "gen") cli_gen "$@" & local pid="$!";;
    "view") cli_view "$@" & local pid="$!";;
    "help")
      echo "Usage: tumblr-gif <task> [...]" 1>&2
      cat 1>&2 <<HELP

    clean    :  delete all png
    gen      :  generate gif which meets tumblr gif specification
    help     :  display this help message
    version  :  display version
    view     :  generating and viewing png

HELP
      status=0
      ;;
    "version")
      echo "tumblr-gif 0.1.0 (bash $BASH_VERSION)"
      status=0
      ;;
    *) echo "Unknown Command: $cmd" 1>&2;;
  esac
  if [ ! -z "$pid" ]; then
      wait "$pid"
      local status=$?
  fi
  return $status
}
__run "$@"
export __STATUS="$?"
exit $__STATUS
